```
원형의 색상환을 0인덱스로 잘라서 한줄에서 양옆을 제외하고 고르는 경우의 수를 dp로 정리한다.
i개의 색에서 1개를 고르는 방법은 i개 만큼 있고 i개에서 0개를 고르는 방법은 항상 1개이다.
2개 이상의 색 중 2개이상의 경우를 고르는 경우를 dp에 정리한다.
i개 색에서 j개의 색을 고르는 방법은 i번째 색을 고를경우와 고르지 않을 경우로 나눌 수 있는데
i번째 색을 고르지 않을 경우는 i-1 번까지의 색중에 j개를 뽑는 경우의 수와 같다.
i번째 색을 고를 경우는 i-1번을 선택 할 수 없으므로 1-2번째까지의 색중에서 j - 1개(현재뽑을 한개를 뺀 수)를 뽑는 경우의 수와 같다.
이를더해서 dp[i][j]에 넣어주면 dp테이블이 완성된다.
원형의 경우는 첫번째를 선택할 경우 마지막 인덱스와 두번째 인덱스 색을 고를 수 없고 첫번째를 선택하지 않을 경우 첫번째를 제외한 색들 중에서 K개를 고르면된다.
따라서 반환은 첫번째를 골라서 K -1 개를 첫번째와 먀지막과 두번째인덱스를 제외한 N - 3 개에서 고르는 방법과 첫번째를 고르지 않아서 K개를 첫번째를 제외한 N - 1개에서 고르는 방법의 합이다.
```
```c++
//5936kb 4ms
#include <bits/stdc++.h>

using namespace std;

int N, K;
int dp[1001][1001];
int mod = 1000000003;

int main() {
    cin >> N >> K;
    for(int i = 0; i <= N; ++i) {
        dp[i][1] = i;
        dp[i][0] = 1;
    }

    for(int i = 2; i <=N; ++i) {
        for(int j = 2; j <=K; ++j)
            dp[i][j] = (dp[i - 1][j] + dp[i - 2][j - 1]) % mod;
    }
    cout << (dp[N - 1][K] + dp[N - 3][K - 1]) % mod;
}
```
