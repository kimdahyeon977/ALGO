```
✨접근법
문제 이해못해서 https://welog.tistory.com/327 참고함
1. 처음에는 heapq 하나만 사용하려고 했으나, 생각해보니까 popleft가 없음
2. 그래서 min_q / max_q를 두개 따로 만들어서 각각 오름차순 / 내림차순으로 저장
3. 근데 이렇게 하면 생기는 문제는 solved로 문제를 제거할때 두개의 q에서 동시에 처리하는 것이 힘들기 때문에 제거할 문제는 dictionary로 저장하기
```
```python
import sys
import heapq
input = sys.stdin.readline
 
def recommend(flag,heap):
    flag = -flag
    while heap and (heap[0][1]*flag not in problem_dict.keys() or problem_dict[heap[0][1]*flag] != heap[0][0]*flag): #제거된 항목에 없는 문제만 남거나 / 이미 제거된 문제이지만, 난이도가 다른 경우만 남을때까지
        heapq.heappop(heap) #제거된 항목 제거하기
    result = heap[0]
    result = result[1]*flag
    return result
 
N = int(input())
max_heap = []
min_heap = []
problem_dict = {}
for _ in range(N):
    pb_num,l_num = map(int,input().split())
    max_heap.append((-l_num,-pb_num))
    min_heap.append((l_num,pb_num))
 
    problem_dict[pb_num] = l_num
heapq.heapify(max_heap)
heapq.heapify(min_heap)
M = int(input())
 
for _ in range(M):
    command,*arg = input().split()
    if command == 'add':
        pb_num,l_num = map(int,arg)
        heapq.heappush(max_heap,(-l_num,-pb_num))
        heapq.heappush(min_heap,(l_num,pb_num))
        problem_dict[pb_num] = l_num
    elif command == 'solved':
        pb_num = int(arg[0])
        del problem_dict[pb_num]
    else:
        flag = int(arg[0])
        if flag > 0:
            print(recommend(flag,max_heap))
        else:
            print(recommend(flag,min_heap))